// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Credit is an object representing the database table.
type Credit struct {
	ID            string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	UserID        string      `boil:"user_id" json:"user_id" toml:"user_id" yaml:"user_id"`
	Address       string      `boil:"address" json:"address" toml:"address" yaml:"address"`
	TokenID       int         `boil:"token_id" json:"token_id" toml:"token_id" yaml:"token_id"`
	TokenSymbol   string      `boil:"token_symbol" json:"token_symbol" toml:"token_symbol" yaml:"token_symbol"`
	Amount        string      `boil:"amount" json:"amount" toml:"amount" yaml:"amount"`
	CreditType    string      `boil:"credit_type" json:"credit_type" toml:"credit_type" yaml:"credit_type"`
	BusinessType  string      `boil:"business_type" json:"business_type" toml:"business_type" yaml:"business_type"`
	ReferenceID   string      `boil:"reference_id" json:"reference_id" toml:"reference_id" yaml:"reference_id"`
	ReferenceType string      `boil:"reference_type" json:"reference_type" toml:"reference_type" yaml:"reference_type"`
	ChainID       null.Int    `boil:"chain_id" json:"chain_id,omitempty" toml:"chain_id" yaml:"chain_id,omitempty"`
	ChainType     null.String `boil:"chain_type" json:"chain_type,omitempty" toml:"chain_type" yaml:"chain_type,omitempty"`
	Status        string      `boil:"status" json:"status" toml:"status" yaml:"status"`
	BlockNumber   null.Int64  `boil:"block_number" json:"block_number,omitempty" toml:"block_number" yaml:"block_number,omitempty"`
	TXHash        null.String `boil:"tx_hash" json:"tx_hash,omitempty" toml:"tx_hash" yaml:"tx_hash,omitempty"`
	EventIndex    null.Int    `boil:"event_index" json:"event_index,omitempty" toml:"event_index" yaml:"event_index,omitempty"`
	Metadata      null.JSON   `boil:"metadata" json:"metadata,omitempty" toml:"metadata" yaml:"metadata,omitempty"`
	CreatedAt     time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt     time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *creditR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L creditL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CreditColumns = struct {
	ID            string
	UserID        string
	Address       string
	TokenID       string
	TokenSymbol   string
	Amount        string
	CreditType    string
	BusinessType  string
	ReferenceID   string
	ReferenceType string
	ChainID       string
	ChainType     string
	Status        string
	BlockNumber   string
	TXHash        string
	EventIndex    string
	Metadata      string
	CreatedAt     string
	UpdatedAt     string
}{
	ID:            "id",
	UserID:        "user_id",
	Address:       "address",
	TokenID:       "token_id",
	TokenSymbol:   "token_symbol",
	Amount:        "amount",
	CreditType:    "credit_type",
	BusinessType:  "business_type",
	ReferenceID:   "reference_id",
	ReferenceType: "reference_type",
	ChainID:       "chain_id",
	ChainType:     "chain_type",
	Status:        "status",
	BlockNumber:   "block_number",
	TXHash:        "tx_hash",
	EventIndex:    "event_index",
	Metadata:      "metadata",
	CreatedAt:     "created_at",
	UpdatedAt:     "updated_at",
}

var CreditTableColumns = struct {
	ID            string
	UserID        string
	Address       string
	TokenID       string
	TokenSymbol   string
	Amount        string
	CreditType    string
	BusinessType  string
	ReferenceID   string
	ReferenceType string
	ChainID       string
	ChainType     string
	Status        string
	BlockNumber   string
	TXHash        string
	EventIndex    string
	Metadata      string
	CreatedAt     string
	UpdatedAt     string
}{
	ID:            "credits.id",
	UserID:        "credits.user_id",
	Address:       "credits.address",
	TokenID:       "credits.token_id",
	TokenSymbol:   "credits.token_symbol",
	Amount:        "credits.amount",
	CreditType:    "credits.credit_type",
	BusinessType:  "credits.business_type",
	ReferenceID:   "credits.reference_id",
	ReferenceType: "credits.reference_type",
	ChainID:       "credits.chain_id",
	ChainType:     "credits.chain_type",
	Status:        "credits.status",
	BlockNumber:   "credits.block_number",
	TXHash:        "credits.tx_hash",
	EventIndex:    "credits.event_index",
	Metadata:      "credits.metadata",
	CreatedAt:     "credits.created_at",
	UpdatedAt:     "credits.updated_at",
}

// Generated where

type whereHelpernull_Int64 struct{ field string }

func (w whereHelpernull_Int64) EQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int64) NEQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int64) LT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int64) LTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int64) GT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int64) GTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_JSON struct{ field string }

func (w whereHelpernull_JSON) EQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_JSON) NEQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_JSON) LT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_JSON) LTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_JSON) GT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_JSON) GTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_JSON) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_JSON) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var CreditWhere = struct {
	ID            whereHelperstring
	UserID        whereHelperstring
	Address       whereHelperstring
	TokenID       whereHelperint
	TokenSymbol   whereHelperstring
	Amount        whereHelperstring
	CreditType    whereHelperstring
	BusinessType  whereHelperstring
	ReferenceID   whereHelperstring
	ReferenceType whereHelperstring
	ChainID       whereHelpernull_Int
	ChainType     whereHelpernull_String
	Status        whereHelperstring
	BlockNumber   whereHelpernull_Int64
	TXHash        whereHelpernull_String
	EventIndex    whereHelpernull_Int
	Metadata      whereHelpernull_JSON
	CreatedAt     whereHelpertime_Time
	UpdatedAt     whereHelpertime_Time
}{
	ID:            whereHelperstring{field: "\"credits\".\"id\""},
	UserID:        whereHelperstring{field: "\"credits\".\"user_id\""},
	Address:       whereHelperstring{field: "\"credits\".\"address\""},
	TokenID:       whereHelperint{field: "\"credits\".\"token_id\""},
	TokenSymbol:   whereHelperstring{field: "\"credits\".\"token_symbol\""},
	Amount:        whereHelperstring{field: "\"credits\".\"amount\""},
	CreditType:    whereHelperstring{field: "\"credits\".\"credit_type\""},
	BusinessType:  whereHelperstring{field: "\"credits\".\"business_type\""},
	ReferenceID:   whereHelperstring{field: "\"credits\".\"reference_id\""},
	ReferenceType: whereHelperstring{field: "\"credits\".\"reference_type\""},
	ChainID:       whereHelpernull_Int{field: "\"credits\".\"chain_id\""},
	ChainType:     whereHelpernull_String{field: "\"credits\".\"chain_type\""},
	Status:        whereHelperstring{field: "\"credits\".\"status\""},
	BlockNumber:   whereHelpernull_Int64{field: "\"credits\".\"block_number\""},
	TXHash:        whereHelpernull_String{field: "\"credits\".\"tx_hash\""},
	EventIndex:    whereHelpernull_Int{field: "\"credits\".\"event_index\""},
	Metadata:      whereHelpernull_JSON{field: "\"credits\".\"metadata\""},
	CreatedAt:     whereHelpertime_Time{field: "\"credits\".\"created_at\""},
	UpdatedAt:     whereHelpertime_Time{field: "\"credits\".\"updated_at\""},
}

// CreditRels is where relationship names are stored.
var CreditRels = struct {
	Token string
	User  string
}{
	Token: "Token",
	User:  "User",
}

// creditR is where relationships are stored.
type creditR struct {
	Token *Token `boil:"Token" json:"Token" toml:"Token" yaml:"Token"`
	User  *User  `boil:"User" json:"User" toml:"User" yaml:"User"`
}

// NewStruct creates a new relationship struct
func (*creditR) NewStruct() *creditR {
	return &creditR{}
}

func (o *Credit) GetToken() *Token {
	if o == nil {
		return nil
	}

	return o.R.GetToken()
}

func (r *creditR) GetToken() *Token {
	if r == nil {
		return nil
	}

	return r.Token
}

func (o *Credit) GetUser() *User {
	if o == nil {
		return nil
	}

	return o.R.GetUser()
}

func (r *creditR) GetUser() *User {
	if r == nil {
		return nil
	}

	return r.User
}

// creditL is where Load methods for each relationship are stored.
type creditL struct{}

var (
	creditAllColumns            = []string{"id", "user_id", "address", "token_id", "token_symbol", "amount", "credit_type", "business_type", "reference_id", "reference_type", "chain_id", "chain_type", "status", "block_number", "tx_hash", "event_index", "metadata", "created_at", "updated_at"}
	creditColumnsWithoutDefault = []string{"user_id", "address", "token_id", "token_symbol", "amount", "credit_type", "business_type", "reference_id", "reference_type", "status"}
	creditColumnsWithDefault    = []string{"id", "chain_id", "chain_type", "block_number", "tx_hash", "event_index", "metadata", "created_at", "updated_at"}
	creditPrimaryKeyColumns     = []string{"id"}
	creditGeneratedColumns      = []string{}
)

type (
	// CreditSlice is an alias for a slice of pointers to Credit.
	// This should almost always be used instead of []Credit.
	CreditSlice []*Credit

	creditQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	creditType                 = reflect.TypeOf(&Credit{})
	creditMapping              = queries.MakeStructMapping(creditType)
	creditPrimaryKeyMapping, _ = queries.BindMapping(creditType, creditMapping, creditPrimaryKeyColumns)
	creditInsertCacheMut       sync.RWMutex
	creditInsertCache          = make(map[string]insertCache)
	creditUpdateCacheMut       sync.RWMutex
	creditUpdateCache          = make(map[string]updateCache)
	creditUpsertCacheMut       sync.RWMutex
	creditUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single credit record from the query.
func (q creditQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Credit, error) {
	o := &Credit{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for credits")
	}

	return o, nil
}

// All returns all Credit records from the query.
func (q creditQuery) All(ctx context.Context, exec boil.ContextExecutor) (CreditSlice, error) {
	var o []*Credit

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Credit slice")
	}

	return o, nil
}

// Count returns the count of all Credit records in the query.
func (q creditQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count credits rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q creditQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if credits exists")
	}

	return count > 0, nil
}

// Token pointed to by the foreign key.
func (o *Credit) Token(mods ...qm.QueryMod) tokenQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TokenID),
	}

	queryMods = append(queryMods, mods...)

	return Tokens(queryMods...)
}

// User pointed to by the foreign key.
func (o *Credit) User(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.UserID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// LoadToken allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (creditL) LoadToken(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCredit interface{}, mods queries.Applicator) error {
	var slice []*Credit
	var object *Credit

	if singular {
		var ok bool
		object, ok = maybeCredit.(*Credit)
		if !ok {
			object = new(Credit)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCredit)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCredit))
			}
		}
	} else {
		s, ok := maybeCredit.(*[]*Credit)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCredit)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCredit))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &creditR{}
		}
		args[object.TokenID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &creditR{}
			}

			args[obj.TokenID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`tokens`),
		qm.WhereIn(`tokens.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Token")
	}

	var resultSlice []*Token
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Token")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for tokens")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tokens")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Token = foreign
		if foreign.R == nil {
			foreign.R = &tokenR{}
		}
		foreign.R.Credits = append(foreign.R.Credits, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.TokenID == foreign.ID {
				local.R.Token = foreign
				if foreign.R == nil {
					foreign.R = &tokenR{}
				}
				foreign.R.Credits = append(foreign.R.Credits, local)
				break
			}
		}
	}

	return nil
}

// LoadUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (creditL) LoadUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCredit interface{}, mods queries.Applicator) error {
	var slice []*Credit
	var object *Credit

	if singular {
		var ok bool
		object, ok = maybeCredit.(*Credit)
		if !ok {
			object = new(Credit)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCredit)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCredit))
			}
		}
	} else {
		s, ok := maybeCredit.(*[]*Credit)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCredit)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCredit))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &creditR{}
		}
		args[object.UserID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &creditR{}
			}

			args[obj.UserID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.User = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.Credits = append(foreign.R.Credits, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.UserID == foreign.ID {
				local.R.User = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.Credits = append(foreign.R.Credits, local)
				break
			}
		}
	}

	return nil
}

// SetToken of the credit to the related item.
// Sets o.R.Token to related.
// Adds o to related.R.Credits.
func (o *Credit) SetToken(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Token) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"credits\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"token_id"}),
		strmangle.WhereClause("\"", "\"", 2, creditPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.TokenID = related.ID
	if o.R == nil {
		o.R = &creditR{
			Token: related,
		}
	} else {
		o.R.Token = related
	}

	if related.R == nil {
		related.R = &tokenR{
			Credits: CreditSlice{o},
		}
	} else {
		related.R.Credits = append(related.R.Credits, o)
	}

	return nil
}

// SetUser of the credit to the related item.
// Sets o.R.User to related.
// Adds o to related.R.Credits.
func (o *Credit) SetUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"credits\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
		strmangle.WhereClause("\"", "\"", 2, creditPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.UserID = related.ID
	if o.R == nil {
		o.R = &creditR{
			User: related,
		}
	} else {
		o.R.User = related
	}

	if related.R == nil {
		related.R = &userR{
			Credits: CreditSlice{o},
		}
	} else {
		related.R.Credits = append(related.R.Credits, o)
	}

	return nil
}

// Credits retrieves all the records using an executor.
func Credits(mods ...qm.QueryMod) creditQuery {
	mods = append(mods, qm.From("\"credits\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"credits\".*"})
	}

	return creditQuery{q}
}

// FindCredit retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCredit(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Credit, error) {
	creditObj := &Credit{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"credits\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, creditObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from credits")
	}

	return creditObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Credit) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no credits provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(creditColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	creditInsertCacheMut.RLock()
	cache, cached := creditInsertCache[key]
	creditInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			creditAllColumns,
			creditColumnsWithDefault,
			creditColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(creditType, creditMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(creditType, creditMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"credits\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"credits\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into credits")
	}

	if !cached {
		creditInsertCacheMut.Lock()
		creditInsertCache[key] = cache
		creditInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Credit.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Credit) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	key := makeCacheKey(columns, nil)
	creditUpdateCacheMut.RLock()
	cache, cached := creditUpdateCache[key]
	creditUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			creditAllColumns,
			creditPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update credits, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"credits\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, creditPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(creditType, creditMapping, append(wl, creditPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update credits row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for credits")
	}

	if !cached {
		creditUpdateCacheMut.Lock()
		creditUpdateCache[key] = cache
		creditUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q creditQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for credits")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for credits")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CreditSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), creditPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"credits\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, creditPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in credit slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all credit")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Credit) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no credits provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(creditColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	creditUpsertCacheMut.RLock()
	cache, cached := creditUpsertCache[key]
	creditUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			creditAllColumns,
			creditColumnsWithDefault,
			creditColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			creditAllColumns,
			creditPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert credits, could not build update column list")
		}

		ret := strmangle.SetComplement(creditAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(creditPrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert credits, could not build conflict column list")
			}

			conflict = make([]string, len(creditPrimaryKeyColumns))
			copy(conflict, creditPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"credits\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(creditType, creditMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(creditType, creditMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert credits")
	}

	if !cached {
		creditUpsertCacheMut.Lock()
		creditUpsertCache[key] = cache
		creditUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Credit record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Credit) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Credit provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), creditPrimaryKeyMapping)
	sql := "DELETE FROM \"credits\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from credits")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for credits")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q creditQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no creditQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from credits")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for credits")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CreditSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), creditPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"credits\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, creditPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from credit slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for credits")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Credit) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCredit(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CreditSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CreditSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), creditPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"credits\".* FROM \"credits\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, creditPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CreditSlice")
	}

	*o = slice

	return nil
}

// CreditExists checks if the Credit row exists.
func CreditExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"credits\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if credits exists")
	}

	return exists, nil
}

// Exists checks if the Credit row exists.
func (o *Credit) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return CreditExists(ctx, exec, o.ID)
}
